{
  "meta": {
    "title": "Shakeel Haider - Blog",
    "description": "Blog o artÃ­culo de Shakeel Haider sobre React, NestJS y desarrollo web full-stack.",
    "keywords": "shakeel haider, blog, react, nestjs, desarrollo full-stack, desarrollo web, programaciÃ³n, javascript, typescript",
    "author": "Shakeel Haider"
  },

  "data": {
    "title": "Blog",

    "items": [
      {
        "id": "1",
        "title": "Por quÃ© elegÃ­ React + NestJS para el desarrollo Full-Stack",
        "slug": "why-i-chose-react-nestjs-for-full-stack-development",
        "authorId": "user123",
        "createdAt": "2025-05-12T10:00:00Z",
        "updatedAt": "2025-05-12T10:00:00Z",
        "isPublished": true,
        "content": [
          {
            "type": "image",
            "url": "/images/blogs/why-i-chose-react-nestjs.png",
            "alt": "Logotipos de React y NestJS"
          },
          {
            "type": "heading",
            "level": 1,
            "text": "ğŸ§  Por quÃ© elegÃ­ React + NestJS para el desarrollo Full-Stack"
          },
          {
            "type": "paragraph",
            "text": "Como desarrollador full-stack, elegir la pila tecnolÃ³gica adecuada no se trata solo de la publicidad, sino de la productividad, la escalabilidad y la mantenibilidad a largo plazo. DespuÃ©s de construir varios proyectos utilizando diferentes pilas, encontrÃ© que la combinaciÃ³n de React (para el frontend) y NestJS (para el backend) era una combinaciÃ³n perfecta. He aquÃ­ por quÃ©."
          },
          {
            "type": "heading",
            "level": 2,
            "text": "ğŸ”· 1. React â€“ Una potencia en el Frontend"
          },
          {
            "type": "paragraph",
            "text": "React es mi framework de frontend preferido por varias razones clave:"
          },
          {
            "type": "list",
            "style": "unordered",
            "items": [
              "Arquitectura basada en componentes: Fomenta la lÃ³gica de UI reutilizable",
              "Enorme ecosistema: Toneladas de librerÃ­as (React Router, Zustand, Redux, Tailwind)",
              "Experiencia de desarrollador: Recarga en caliente, herramientas de desarrollo, pruebas sencillas",
              "Comunidad y mercado laboral fuertes"
            ]
          },
          {
            "type": "paragraph",
            "text": "Un ejemplo sencillo: Un componente de botÃ³n en React"
          },
          {
            "type": "code",
            "language": "jsx",
            "code": "// components/Button.tsx\nimport React from 'react';\n\ntype ButtonProps = {\n    label: string;\n    onClick: () => void;\n  };\n  \n  const Button: React.FC<ButtonProps> = ({ label, onClick }) => {\n    return (\n      <button className=\"px-4 py-2 bg-blue-500 text-white rounded\" onClick={onClick}>\n        {label}\n      </button>\n    );\n  };\n  \n  export default Button;"
          },
          {
            "type": "paragraph",
            "text": "Este patrÃ³n de componente reutilizable es una de las mayores ventajas de React."
          },
          {
            "type": "heading",
            "level": 2,
            "text": "ğŸ›¡ï¸ 2. NestJS â€“ Backend escalable y estructurado"
          },
          {
            "type": "paragraph",
            "text": "NestJS me llamÃ³ la atenciÃ³n porque es:"
          },
          {
            "type": "list",
            "style": "unordered",
            "items": [
              "Opinionado: Proporciona estructura, a diferencia de Express puro",
              "TypeScript-first: Seguridad de tipos en toda la aplicaciÃ³n",
              "Modular: Ideal para escalar proyectos",
              "Soporta REST, GraphQL, WebSockets, Microservicios",
              "FÃ¡cil integraciÃ³n de bases de datos"
            ]
          },
          {
            "type": "paragraph",
            "text": "Ejemplo: Una ruta sencilla en NestJS"
          },
          {
            "type": "code",
            "language": "ts",
            "code": "// users.controller.ts\nimport { Controller, Get } from '@nestjs/common';\n\n@Controller('users')\nexport class UsersController {\n  @Get()\n  findAll() {\n    return [{ id: 1, name: 'John Doe' }];\n  }\n}"
          },
          {
            "type": "paragraph",
            "text": "Legible, comprobable y escalable desde el principio."
          },
          {
            "type": "heading",
            "level": 2,
            "text": "ğŸ”— 3. ComparticiÃ³n de tipos entre Frontend y Backend"
          },
          {
            "type": "paragraph",
            "text": "Dado que tanto React como NestJS utilizan TypeScript, puedo compartir tipos/interfaces entre el frontend y el backend, evitando declaraciones redundantes y reduciendo errores."
          },
          {
            "type": "paragraph",
            "text": "Ejemplo de tipo compartido"
          },
          {
            "type": "code",
            "language": "ts",
            "code": "// shared/types.ts\nexport type User = {\n  id: string;\n  name: string;\n  email: string;\n};"
          },
          {
            "type": "paragraph",
            "text": "En NestJS:"
          },
          {
            "type": "code",
            "language": "ts",
            "code": "import { User } from '../shared/types';"
          },
          {
            "type": "paragraph",
            "text": "En React:"
          },
          {
            "type": "code",
            "language": "ts",
            "code": "import { User } from '../shared/types';"
          },
          {
            "type": "paragraph",
            "text": "Sin discrepancias. Sin conjeturas."
          },
          {
            "type": "heading",
            "level": 2,
            "text": "ğŸ§© 4. FÃ¡cil integraciÃ³n de API"
          },
          {
            "type": "paragraph",
            "text": "React + NestJS facilita la obtenciÃ³n y renderizaciÃ³n de datos:"
          },
          {
            "type": "code",
            "language": "jsx",
            "code": "// Fetching users in React\nuseEffect(() => {\nfetch('/api/users')\n.then(res => res.json())\n      .then(data => setUsers(data));\n  }, []);"
          },
          {
            "type": "paragraph",
            "text": "El backend se mantiene limpio y mantenible, el frontend sigue siendo receptivo e interactivo."
          },
          {
            "type": "heading",
            "level": 2,
            "text": "ğŸš€ Reflexiones finales"
          },
          {
            "type": "paragraph",
            "text": "Elegir React + NestJS no fue aleatorio. SurgiÃ³ de la creaciÃ³n de aplicaciones del mundo real y de la comprensiÃ³n de dÃ³nde aparecen los cuellos de botella. Esta pila me ha ayudado a:"
          },
          {
            "type": "list",
            "style": "unordered",
            "items": [
              "Moverme mÃ¡s rÃ¡pido sin sacrificar la estructura",
              "Mantener y escalar aplicaciones con confianza",
              "Entregar aplicaciones web y mÃ³viles de manera eficiente (especialmente con React Native)"
            ]
          },
          {
            "type": "paragraph",
            "text": "Si estÃ¡s decidiendo tu arquitectura full-stack o vienes de un entorno MERN, te recomiendo encarecidamente que pruebes React + NestJS."
          }
        ]
      },
      {
        "id": "remix-vs-nextjs-2025",
        "title": "ğŸ¥Š Remix vs Next.js â€” Â¿Por quÃ© elegir RemixJS?",
        "slug": "remix-vs-nextjs-why-choose-remixjs",
        "authorId": "shakeel-haider",
        "createdAt": "2025-05-13T10:00:00Z",
        "updatedAt": "2025-05-13T10:00:00Z",
        "isPublished": true,
        "content": [
          {
            "type": "image",
            "url": "/images/blogs/remix-vs-nextjs-why-choose-remixjs.png",
            "alt": "Logotipos de React y NestJS"
          },
          {
            "type": "heading",
            "level": 1,
            "text": "ğŸ¥Š Remix vs Next.js â€” Â¿Por quÃ© elegir RemixJS?"
          },
          {
            "type": "paragraph",
            "text": "Tanto Remix como Next.js son potentes frameworks de React full-stack diseÃ±ados para construir aplicaciones web modernas. Si bien Next.js es un jugador establecido respaldado por Vercel, RemixJS es el framework mÃ¡s nuevo, centrado en los estÃ¡ndares web, que estÃ¡ ganando rÃ¡pidamente atenciÃ³n por su rendimiento, simplicidad y modelo de manejo de datos."
          },
          {
            "type": "paragraph",
            "text": "En este artÃ­culo, profundizaremos en lo que diferencia a Remix de Next.js, y por quÃ© Remix podrÃ­a ser la mejor opciÃ³n para tu prÃ³ximo proyecto, especialmente si buscas velocidad, mantenibilidad y alineaciÃ³n fundamental con la web."
          },
          {
            "type": "heading",
            "level": 2,
            "text": "ğŸš€ RemixJS a simple vista"
          },
          {
            "type": "list",
            "style": "unordered",
            "items": [
              "Framework React full-stack",
              "Construido alrededor de los fundamentos web (como cachÃ© HTTP, formularios nativos)",
              "Abraza la mejora progresiva",
              "Enfoque en el rendimiento rÃ¡pido a travÃ©s de una dependencia mÃ­nima de JavaScript",
              "Funciona con cualquier destino de despliegue (Node, Cloudflare, Deno, etc.)"
            ]
          },
          {
            "type": "heading",
            "level": 2,
            "text": "ğŸ” Ventajas clave de Remix sobre Next.js"
          },
          {
            "type": "paragraph",
            "text": "Comparemos ambos basÃ¡ndonos en las preocupaciones reales de los desarrolladores y las diferencias arquitectÃ³nicas."
          },
          {
            "type": "heading",
            "level": 3,
            "text": "1. ğŸ§  Modelo de carga de datos"
          },
          {
            "type": "paragraph",
            "text": "âœ… Remix: Primero el servidor, loaders co-ubicados\nCada ruta en Remix define una funciÃ³n `loader()` que se ejecuta en el servidor antes de renderizar. Obtiene todos los datos requeridos en paralelo y los envÃ­a como parte de la respuesta."
          },
          {
            "type": "code",
            "language": "jsx",
            "code": "// app/routes/posts.tsx\nexport const loader = async () => {\nconst posts = await getPosts();\nreturn json(posts);\n};"
          },
          {
            "type": "paragraph",
            "text": "ğŸš« Next.js: getServerSideProps o getStaticProps\nNext.js separa la obtenciÃ³n de datos en funciones especiales, pero solo a nivel de pÃ¡gina, lo que limita la reutilizaciÃ³n y la composiciÃ³n para componentes anidados."
          },
          {
            "type": "code",
            "language": "jsx",
            "code": "// pages/posts.js\nexport async function getServerSideProps() {\n  const posts = await getPosts();\n  return { props: { posts } };\n}"
          },
          {
            "type": "paragraph",
            "text": "ğŸ” Veredicto: Remix simplifica la obtenciÃ³n de datos al vincularla directamente a la ruta, incluso las anidadas, lo que conduce a un mejor rendimiento y estructura."
          },
          {
            "type": "heading",
            "level": 3,
            "text": "2. ğŸ§­ Enrutamiento y diseÃ±os anidados"
          },
          {
            "type": "paragraph",
            "text": "âœ… Remix: Rutas anidadas nativas\nLas rutas de Remix estÃ¡n co-ubicadas y inherentemente anidadas. Los diseÃ±os y las rutas se estructuran como carpetas, y puedes tener loaders a nivel de diseÃ±o."
          },
          {
            "type": "code",
            "language": "text",
            "code": "routes/\nâ”œâ”€â”€ dashboard.tsx        --> /dashboard\nâ””â”€â”€ dashboard/\n    â””â”€â”€ settings.tsx     --> /dashboard/settings"
          },
          {
            "type": "paragraph",
            "text": "ğŸš« Next.js: App Router y convenciones de archivos\nNext.js introdujo recientemente el enrutamiento basado en directorios de aplicaciones, que admite diseÃ±os, pero es mÃ¡s nuevo y complejo, y no se integra profundamente con los datos del lado del servidor en los diseÃ±os."
          },
          {
            "type": "paragraph",
            "text": "ğŸ” Veredicto: Las rutas anidadas de Remix son mÃ¡s fÃ¡ciles de entender, mÃ¡s flexibles y escalan mejor con jerarquÃ­as de UI complejas."
          },
          {
            "type": "heading",
            "level": 3,
            "text": "3. âš¡ Rendimiento: Menos JavaScript en el cliente"
          },
          {
            "type": "paragraph",
            "text": "âœ… Remix: Dependencia mÃ­nima de JS\nRemix carga la menor cantidad de JS posible. Se basa en el comportamiento estÃ¡ndar del navegador, como el envÃ­o de formularios nativos y el almacenamiento en cachÃ©, para reducir la lÃ³gica del lado del cliente."
          },
          {
            "type": "paragraph",
            "text": "ğŸš« Next.js: Interactividad pesada en el cliente\nNext.js se apoya mÃ¡s en la hidrataciÃ³n y en las API del lado del cliente, lo que a menudo conduce a paquetes mÃ¡s pesados."
          },
          {
            "type": "paragraph",
            "text": "ğŸ” Veredicto: Las aplicaciones Remix suelen ser mÃ¡s rÃ¡pidas por defecto porque descargan mÃ¡s trabajo en el navegador y el servidor."
          },
          {
            "type": "heading",
            "level": 3,
            "text": "4. ğŸ“¤ Formularios y acciones"
          },
          {
            "type": "paragraph",
            "text": "âœ… Remix: Formularios progresivos y alimentados por el servidor\nLos formularios en Remix usan etiquetas `<form>` nativas con funciones `action()` del lado del servidor para manejar envÃ­os, sin necesidad de JavaScript."
          },
          {
            "type": "code",
            "language": "jsx",
            "code": "export const action = async ({ request }) => {\n  const formData = await request.formData();\n  await savePost(formData);\n  return redirect(\"/success\");\n};"
          },
          {
            "type": "paragraph",
            "text": "ğŸš« Next.js: Requiere JavaScript + rutas API\nLos formularios de Next.js se suelen manejar a travÃ©s de `fetch` o librerÃ­as del lado del cliente. No hay un manejo de formularios incorporado como en Remix."
          },
          {
            "type": "paragraph",
            "text": "ğŸ” Veredicto: Remix recupera la simplicidad de las aplicaciones tradicionales renderizadas por el servidor, lo que permite formularios rÃ¡pidos y progresivos con menos cÃ³digo de cliente."
          },
          {
            "type": "heading",
            "level": 3,
            "text": "5. ğŸŒ Almacenamiento en cachÃ© y fundamentos web"
          },
          {
            "type": "paragraph",
            "text": "âœ… Remix: Construido sobre el almacenamiento en cachÃ© HTTP\nPuedes controlar el almacenamiento en cachÃ© a nivel de loader, lo que permite un control inteligente sobre lo que el navegador o la CDN almacenan."
          },
          {
            "type": "code",
            "language": "ts",
            "code": "export const loader: LoaderFunction = async ({ request }) => {\n  return new Response(JSON.stringify(data), {\n    headers: { \"Cache-Control\": \"max-age=3600\" },\n  });\n};"
          },
          {
            "type": "paragraph",
            "text": "ğŸš« Next.js: Principalmente manejado por optimizaciones especÃ­ficas de Vercel\nPuedes controlar los encabezados, pero es mÃ¡s abstracto y menos flexible si no estÃ¡ alojado en Vercel."
          },
          {
            "type": "paragraph",
            "text": "ğŸ” Veredicto: Remix ofrece control directo sobre las respuestas HTTP y la cachÃ©, adoptando los principios nativos de la web."
          },
          {
            "type": "heading",
            "level": 3,
            "text": "6. ğŸ› ï¸ Flexibilidad de despliegue"
          },
          {
            "type": "list",
            "style": "unordered",
            "items": [
              "Remix se ejecuta en Node.js, Deno, Cloudflare Workers, Vercel, Netlify, Fly.io, incluso como una aplicaciÃ³n Express independiente.",
              "Next.js funciona mejor en Vercel (su patrocinador). Los despliegues personalizados son posibles, pero menos fluidos."
            ]
          },
          {
            "type": "paragraph",
            "text": "ğŸ” Veredicto: Si necesitas evitar el bloqueo del proveedor, Remix es mÃ¡s flexible."
          },
          {
            "type": "heading",
            "level": 3,
            "text": "7. ğŸ”§ Experiencia del desarrollador"
          },
          {
            "type": "paragraph",
            "text": "AquÃ­ tienes una rÃ¡pida comparaciÃ³n de caracterÃ­sticas entre Remix y Next.js:"
          },
          {
            "type": "list",
            "style": "unordered",
            "items": [
              "Enrutamiento â€” Remix: Anidado, layout-first | Next.js: Plano por defecto (PÃ¡ginas), el directorio App es nuevo",
              "ObtenciÃ³n de datos â€” Remix: Loaders basados en rutas | Next.js: getServerSideProps, rutas API",
              "Formularios â€” Remix: Nativos con acciones | Next.js: JS personalizado + endpoints API",
              "Almacenamiento en cachÃ© â€” Remix: Control HTTP completo | Next.js: Manejado por Vercel o personalizado",
              "JS del cliente â€” Remix: MÃ¡s pequeÃ±o, mÃ­nimo | Next.js: MÃ¡s grande, con mucha hidrataciÃ³n",
              "Despliegue â€” Remix: Cualquiera (Cloudflare, Denoâ€¦) | Next.js: Mejor en Vercel"
            ]
          },
          {
            "type": "heading",
            "level": 2,
            "text": "ğŸ§© Â¿CuÃ¡ndo deberÃ­as elegir Remix en lugar de Next.js?"
          },
          {
            "type": "list",
            "style": "unordered",
            "items": [
              "âœ… Quieres mejora progresiva y rendimiento rÃ¡pido",
              "âœ… Te importa el control profundo sobre el enrutamiento y la obtenciÃ³n de datos",
              "âœ… Prefieres JavaScript mÃ­nimo y un mejor SEO",
              "âœ… Quieres construir aplicaciones que funcionen incluso con JS deshabilitado",
              "âœ… Necesitas opciones de despliegue flexibles mÃ¡s allÃ¡ de Vercel"
            ]
          },
          {
            "type": "heading",
            "level": 2,
            "text": "ğŸ Reflexiones finales"
          },
          {
            "type": "paragraph",
            "text": "Tanto Remix como Next.js son herramientas excelentes. Pero Remix recupera la simplicidad y el rendimiento de las aplicaciones clÃ¡sicas renderizadas por el servidor, sin dejar de ofrecerte las caracterÃ­sticas modernas de React. Favorece los estÃ¡ndares web sobre las abstracciones personalizadas, lo que hace que tus aplicaciones sean rÃ¡pidas, resilientes y mÃ¡s fÃ¡ciles de entender."
          },
          {
            "type": "paragraph",
            "text": "Â¿Necesitas ayuda para migrar una aplicaciÃ³n de Next.js a Remix o para construir una nueva aplicaciÃ³n Remix desde cero? Â¡AvÃ­same! ğŸš€"
          }
        ]
      }
    ]
  }
}
