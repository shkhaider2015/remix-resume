{
  "meta": {
    "title": "Shakeel Haider - Blog",
    "description": "Blog ou article de Shakeel Haider sur React, NestJS et le dÃ©veloppement web full-stack.",
    "keywords": "shakeel haider, blog, react, nestjs, dÃ©veloppement full-stack, dÃ©veloppement web, programmation, javascript, typescript",
    "author": "Shakeel Haider"
  },
  "data": {
    "title": "Blog",
    "items": [
      {
        "id": "1",
        "title": "Pourquoi j'ai choisi React + NestJS pour le dÃ©veloppement Full-Stack",
        "slug": "why-i-chose-react-nestjs-for-full-stack-development",
        "authorId": "user123",
        "createdAt": "2025-05-12T10:00:00Z",
        "updatedAt": "2025-05-12T10:00:00Z",
        "isPublished": true,
        "content": [
          {
            "type": "image",
            "url": "/images/blogs/why-i-chose-react-nestjs.png",
            "alt": "Logos React et NestJS"
          },
          {
            "type": "heading",
            "level": 1,
            "text": "ğŸ§  Pourquoi j'ai choisi React + NestJS pour le dÃ©veloppement Full-Stack"
          },
          {
            "type": "paragraph",
            "text": "En tant que dÃ©veloppeur full-stack, choisir la bonne pile technologique n'est pas seulement une question de battage mÃ©diatique - c'est une question de productivitÃ©, d'Ã©volutivitÃ© et de maintenabilitÃ© Ã  long terme. AprÃ¨s avoir construit plusieurs projets en utilisant diffÃ©rentes piles, j'ai trouvÃ© que la combinaison de React (pour le frontend) et NestJS (pour le backend) Ã©tait une correspondance parfaite. Voici pourquoi."
          },
          {
            "type": "heading",
            "level": 2,
            "text": "ğŸ”· 1. React â€“ Une centrale frontend"
          },
          {
            "type": "paragraph",
            "text": "React est mon framework frontend de prÃ©dilection pour quelques raisons clÃ©s :"
          },
          {
            "type": "list",
            "style": "unordered",
            "items": [
              "Architecture basÃ©e sur les composants : encourage la logique d'interface utilisateur rÃ©utilisable",
              "Ã‰cosystÃ¨me immense : des tonnes de bibliothÃ¨ques (React Router, Zustand, Redux, Tailwind)",
              "ExpÃ©rience dÃ©veloppeur : rechargement Ã  chaud, outils de dÃ©veloppement, tests faciles",
              "Forte communautÃ© et marchÃ© du travail"
            ]
          },
          {
            "type": "paragraph",
            "text": "Un exemple simple : un composant de bouton en React"
          },
          {
            "type": "code",
            "language": "jsx",
            "code": "// components/Button.tsx\nimport React from 'react';\n\ntype ButtonProps = {\n    label: string;\n    onClick: () => void;\n  };\n  \n  const Button: React.FC<ButtonProps> = ({ label, onClick }) => {\n    return (\n      <button className=\"px-4 py-2 bg-blue-500 text-white rounded\" onClick={onClick}>\n        {label}\n      </button>\n    );\n  };\n  \n  export default Button;"
          },
          {
            "type": "paragraph",
            "text": "Ce modÃ¨le de composant rÃ©utilisable est l'un des plus grands avantages de React."
          },
          {
            "type": "heading",
            "level": 2,
            "text": "ğŸ›¡ï¸ 2. NestJS â€“ Backend Ã©volutif et structurÃ©"
          },
          {
            "type": "paragraph",
            "text": "NestJS s'est dÃ©marquÃ© pour moi parce qu'il est :"
          },
          {
            "type": "list",
            "style": "unordered",
            "items": [
              "OpinionÃ© : donne de la structure, contrairement Ã  Express brut",
              "TypeScript-first : sÃ©curitÃ© de type dans toute l'application",
              "Modulaire : idÃ©al pour faire Ã©voluer les projets",
              "Prend en charge REST, GraphQL, WebSockets, Microservices",
              "IntÃ©gration facile de la base de donnÃ©es"
            ]
          },
          {
            "type": "paragraph",
            "text": "Exemple : une route simple dans NestJS"
          },
          {
            "type": "code",
            "language": "ts",
            "code": "// users.controller.ts\nimport { Controller, Get } from '@nestjs/common';\n\n@Controller('users')\nexport class UsersController {\n  @Get()\n  findAll() {\n    return [{ id: 1, name: 'John Doe' }];\n  }\n}"
          },
          {
            "type": "paragraph",
            "text": "Lisible, testable et Ã©volutif dÃ¨s le dÃ©part."
          },
          {
            "type": "heading",
            "level": 2,
            "text": "ğŸ”— 3. Partage de types entre le frontend et le backend"
          },
          {
            "type": "paragraph",
            "text": "Comme React et NestJS utilisent tous deux TypeScript, je peux partager des types/interfaces entre le frontend et le backend, ce qui Ã©vite les dÃ©clarations redondantes et rÃ©duit les bogues."
          },
          {
            "type": "paragraph",
            "text": "Exemple de type partagÃ©"
          },
          {
            "type": "code",
            "language": "ts",
            "code": "// shared/types.ts\nexport type User = {\n  id: string;\n  name: string;\n  email: string;\n};"
          },
          {
            "type": "paragraph",
            "text": "Dans NestJS :"
          },
          {
            "type": "code",
            "language": "ts",
            "code": "import { User } from '../shared/types';"
          },
          {
            "type": "paragraph",
            "text": "Dans React :"
          },
          {
            "type": "code",
            "language": "ts",
            "code": "import { User } from '../shared/types';"
          },
          {
            "type": "paragraph",
            "text": "Pas d'inadÃ©quation. Pas de devinettes."
          },
          {
            "type": "heading",
            "level": 2,
            "text": "ğŸ§© 4. IntÃ©gration facile de l'API"
          },
          {
            "type": "paragraph",
            "text": "React + NestJS facilite la rÃ©cupÃ©ration et le rendu des donnÃ©es :"
          },
          {
            "type": "code",
            "language": "jsx",
            "code": "// Fetching users in React\nuseEffect(() => {\nfetch('/api/users')\n.then(res => res.json())\n      .then(data => setUsers(data));\n  }, []);"
          },
          {
            "type": "paragraph",
            "text": "Le backend reste propre et maintenable, le frontend reste rÃ©actif et interactif."
          },
          {
            "type": "heading",
            "level": 2,
            "text": "ğŸš€ DerniÃ¨res rÃ©flexions"
          },
          {
            "type": "paragraph",
            "text": "Le choix de React + NestJS n'Ã©tait pas alÃ©atoire. Il est nÃ© de la crÃ©ation d'applications rÃ©elles et de la comprÃ©hension des goulots d'Ã©tranglement. Cette pile m'a aidÃ© Ã  :"
          },
          {
            "type": "list",
            "style": "unordered",
            "items": [
              "Aller plus vite sans sacrifier la structure",
              "Maintenir et faire Ã©voluer les applications en toute confiance",
              "Livrer efficacement des applications Web et mobiles (en particulier avec React Native)"
            ]
          },
          {
            "type": "paragraph",
            "text": "Si vous dÃ©cidez de votre architecture full-stack ou si vous venez d'un environnement MERN, je vous recommande vivement d'essayer React + NestJS."
          }
        ]
      },
      {
        "id": "remix-vs-nextjs-2025",
        "title": "ğŸ¥Š Remix vs Next.js â€” Pourquoi choisir RemixJS ?",
        "slug": "remix-vs-nextjs-why-choose-remixjs",
        "authorId": "shakeel-haider",
        "createdAt": "2025-05-13T10:00:00Z",
        "updatedAt": "2025-05-13T10:00:00Z",
        "isPublished": true,
        "content": [
          {
            "type": "image",
            "url": "/images/blogs/remix-vs-nextjs-why-choose-remixjs.png",
            "alt": "Logos React et NestJS"
          },
          {
            "type": "heading",
            "level": 1,
            "text": "ğŸ¥Š Remix vs Next.js â€” Pourquoi choisir RemixJS ?"
          },
          {
            "type": "paragraph",
            "text": "Remix et Next.js sont tous deux de puissants frameworks React full-stack conÃ§us pour crÃ©er des applications web modernes. Alors que Next.js est un acteur de longue date soutenu par Vercel, RemixJS est le nouveau framework axÃ© sur les standards web qui gagne rapidement en attention pour ses performances, sa simplicitÃ© et son modÃ¨le de gestion des donnÃ©es."
          },
          {
            "type": "paragraph",
            "text": "Dans cet article, nous allons voir ce qui distingue Remix de Next.js, et pourquoi Remix pourrait Ãªtre le meilleur choix pour votre prochain projet - surtout si vous recherchez la vitesse, la maintenabilitÃ© et l'alignement sur les fondamentaux du web."
          },
          {
            "type": "heading",
            "level": 2,
            "text": "ğŸš€ RemixJS en un coup d'Å“il"
          },
          {
            "type": "list",
            "style": "unordered",
            "items": [
              "Framework React full-stack",
              "Construit autour des fondamentaux du web (comme la mise en cache HTTP, les formulaires natifs)",
              "Adopte l'amÃ©lioration progressive",
              "Accent sur les performances rapides grÃ¢ce Ã  une dÃ©pendance minimale Ã  JavaScript",
              "Fonctionne avec n'importe quelle cible de dÃ©ploiement (Node, Cloudflare, Deno, etc.)"
            ]
          },
          {
            "type": "heading",
            "level": 2,
            "text": "ğŸ” Principaux avantages de Remix par rapport Ã  Next.js"
          },
          {
            "type": "paragraph",
            "text": "Comparons les deux en fonction des prÃ©occupations rÃ©elles des dÃ©veloppeurs et des diffÃ©rences architecturales."
          },
          {
            "type": "heading",
            "level": 3,
            "text": "1. ğŸ§  ModÃ¨le de chargement des donnÃ©es"
          },
          {
            "type": "paragraph",
            "text": "âœ… Remix : chargeurs co-localisÃ©s et orientÃ©s serveur\nChaque route dans Remix dÃ©finit une fonction `loader()` qui s'exÃ©cute sur le serveur avant le rendu. Elle rÃ©cupÃ¨re toutes les donnÃ©es requises en parallÃ¨le et les envoie dans le cadre de la rÃ©ponse."
          },
          {
            "type": "code",
            "language": "jsx",
            "code": "// app/routes/posts.tsx\nexport const loader = async () => {\nconst posts = await getPosts();\nreturn json(posts);\n};"
          },
          {
            "type": "paragraph",
            "text": "ğŸš« Next.js : getServerSideProps ou getStaticProps\nNext.js sÃ©pare la rÃ©cupÃ©ration des donnÃ©es en fonctions spÃ©ciales, mais uniquement au niveau de la page, ce qui limite la rÃ©utilisabilitÃ© et la composabilitÃ© pour les composants imbriquÃ©s."
          },
          {
            "type": "code",
            "language": "jsx",
            "code": "// pages/posts.js\nexport async function getServerSideProps() {\n  const posts = await getPosts();\n  return { props: { posts } };\n}"
          },
          {
            "type": "paragraph",
            "text": "ğŸ” Verdict : Remix simplifie la rÃ©cupÃ©ration des donnÃ©es en la liant directement Ã  la route, mÃªme les routes imbriquÃ©es - ce qui amÃ©liore les performances et la structure."
          },
          {
            "type": "heading",
            "level": 3,
            "text": "2. ğŸ§­ Routage et mises en page imbriquÃ©s"
          },
          {
            "type": "paragraph",
            "text": "âœ… Remix : routes imbriquÃ©es natives\nLes routes de Remix sont co-localisÃ©es et intrinsÃ¨quement imbriquÃ©es. Les mises en page et les routes sont structurÃ©es comme des dossiers, et vous pouvez avoir des chargeurs au niveau de la mise en page."
          },
          {
            "type": "code",
            "language": "text",
            "code": "routes/\nâ”œâ”€â”€ dashboard.tsx        --> /dashboard\nâ””â”€â”€ dashboard/\n    â””â”€â”€ settings.tsx     --> /dashboard/settings"
          },
          {
            "type": "paragraph",
            "text": "ğŸš« Next.js : App Router et conventions de fichiers\nNext.js a rÃ©cemment introduit le routage basÃ© sur le rÃ©pertoire de l'application, qui prend en charge les mises en page, mais il est plus rÃ©cent et plus complexe, et ne s'intÃ¨gre pas profondÃ©ment avec les donnÃ©es cÃ´tÃ© serveur dans les mises en page."
          },
          {
            "type": "paragraph",
            "text": "ğŸ” Verdict : les routes imbriquÃ©es de Remix sont plus faciles Ã  comprendre, plus flexibles et s'adaptent mieux aux hiÃ©rarchies d'interface utilisateur complexes."
          },
          {
            "type": "heading",
            "level": 3,
            "text": "3. âš¡ Performances : moins de JavaScript cÃ´tÃ© client"
          },
          {
            "type": "paragraph",
            "text": "âœ… Remix : dÃ©pendance JS minimale\nRemix charge le moins de JS possible. Il s'appuie sur le comportement standard du navigateur, comme la soumission de formulaires natifs et la mise en cache, pour rÃ©duire la logique cÃ´tÃ© client."
          },
          {
            "type": "paragraph",
            "text": "ğŸš« Next.js : interactivitÃ© lourde cÃ´tÃ© client\nNext.js s'appuie davantage sur l'hydratation et les API cÃ´tÃ© client, ce qui entraÃ®ne souvent des paquets plus lourds."
          },
          {
            "type": "paragraph",
            "text": "ğŸ” Verdict : les applications Remix sont souvent plus rapides par dÃ©faut car elles dÃ©chargent plus de travail sur le navigateur et le serveur."
          },
          {
            "type": "heading",
            "level": 3,
            "text": "4. ğŸ“¤ Formulaires et actions"
          },
          {
            "type": "paragraph",
            "text": "âœ… Remix : formulaires progressifs alimentÃ©s par le serveur\nLes formulaires dans Remix utilisent des balises `<form>` natives avec des fonctions `action()` cÃ´tÃ© serveur pour gÃ©rer les soumissions - aucun JavaScript n'est nÃ©cessaire."
          },
          {
            "type": "code",
            "language": "jsx",
            "code": "export const action = async ({ request }) => {\n  const formData = await request.formData();\n  await savePost(formData);\n  return redirect(\"/success\");\n};"
          },
          {
            "type": "paragraph",
            "text": "ğŸš« Next.js : nÃ©cessite des routes JavaScript + API\nLes formulaires Next.js sont gÃ©nÃ©ralement gÃ©rÃ©s via `fetch` ou des bibliothÃ¨ques cÃ´tÃ© client. Pas de gestion de formulaire intÃ©grÃ©e comme Remix."
          },
          {
            "type": "paragraph",
            "text": "ğŸ” Verdict : Remix ramÃ¨ne la simplicitÃ© des applications traditionnelles rendues par le serveur, permettant des formulaires rapides et progressifs avec moins de code client."
          },
          {
            "type": "heading",
            "level": 3,
            "text": "5. ğŸŒ Mise en cache et principes fondamentaux du Web"
          },
          {
            "type": "paragraph",
            "text": "âœ… Remix : basÃ© sur la mise en cache HTTP\nVous pouvez contrÃ´ler la mise en cache au niveau du chargeur, ce qui permet un contrÃ´le intelligent de ce que le navigateur ou le CDN stocke."
          },
          {
            "type": "code",
            "language": "ts",
            "code": "export const loader: LoaderFunction = async ({ request }) => {\n  return new Response(JSON.stringify(data), {\n    headers: { \"Cache-Control\": \"max-age=3600\" },\n  });\n};"
          },
          {
            "type": "paragraph",
            "text": "ğŸš« Next.js : principalement gÃ©rÃ© par des optimisations spÃ©cifiques Ã  Vercel\nVous pouvez contrÃ´ler les en-tÃªtes, mais c'est plus abstrait et moins flexible si ce n'est pas hÃ©bergÃ© sur Vercel."
          },
          {
            "type": "paragraph",
            "text": "ğŸ” Verdict : Remix donne un contrÃ´le direct sur les rÃ©ponses HTTP et le cache - adoptant les principes natifs du Web."
          },
          {
            "type": "heading",
            "level": 3,
            "text": "6. ğŸ› ï¸ FlexibilitÃ© de dÃ©ploiement"
          },
          {
            "type": "list",
            "style": "unordered",
            "items": [
              "Remix fonctionne sur Node.js, Deno, Cloudflare Workers, Vercel, Netlify, Fly.io â€” mÃªme en tant qu'application Express autonome.",
              "Next.js fonctionne mieux sur Vercel (son sponsor). Les dÃ©ploiements personnalisÃ©s sont possibles mais moins transparents."
            ]
          },
          {
            "type": "paragraph",
            "text": "ğŸ” Verdict : si vous devez Ã©viter le verrouillage du fournisseur, Remix est plus flexible."
          },
          {
            "type": "heading",
            "level": 3,
            "text": "7. ğŸ”§ ExpÃ©rience dÃ©veloppeur"
          },
          {
            "type": "paragraph",
            "text": "Voici une comparaison rapide des fonctionnalitÃ©s entre Remix et Next.js :"
          },
          {
            "type": "list",
            "style": "unordered",
            "items": [
              "Routage â€” Remix : imbriquÃ©, orientÃ© mise en page | Next.js : plat par dÃ©faut (pages), App Dir est nouveau",
              "RÃ©cupÃ©ration de donnÃ©es â€” Remix : chargeurs basÃ©s sur les routes | Next.js : getServerSideProps, routes API",
              "Formulaires â€” Remix : natif avec des actions | Next.js : JS personnalisÃ© + points de terminaison d'API",
              "Mise en cache â€” Remix : contrÃ´le HTTP complet | Next.js : gÃ©rÃ© par Vercel ou personnalisÃ©",
              "JS client â€” Remix : plus petit, minimal | Next.js : plus grand, lourd en hydratation",
              "DÃ©ploiement â€” Remix : n'importe oÃ¹ (Cloudflare, Denoâ€¦) | Next.js : meilleur sur Vercel"
            ]
          },
          {
            "type": "heading",
            "level": 2,
            "text": "ğŸ§© Quand devriez-vous choisir Remix plutÃ´t que Next.js ?"
          },
          {
            "type": "list",
            "style": "unordered",
            "items": [
              "âœ… Vous voulez une amÃ©lioration progressive et des performances rapides",
              "âœ… Vous vous souciez du contrÃ´le approfondi du routage et de la rÃ©cupÃ©ration des donnÃ©es",
              "âœ… Vous prÃ©fÃ©rez un minimum de JS et un meilleur rÃ©fÃ©rencement",
              "âœ… Vous voulez crÃ©er des applications qui fonctionnent mÃªme avec JS dÃ©sactivÃ©",
              "âœ… Vous avez besoin d'options de dÃ©ploiement flexibles au-delÃ  de Vercel"
            ]
          },
          {
            "type": "heading",
            "level": 2,
            "text": "ğŸ DerniÃ¨res rÃ©flexions"
          },
          {
            "type": "paragraph",
            "text": "Remix et Next.js sont tous deux d'excellents outils. Mais Remix ramÃ¨ne la simplicitÃ© et les performances des applications classiques rendues par le serveur, tout en vous offrant des fonctionnalitÃ©s React modernes. Il privilÃ©gie les standards du Web aux abstractions personnalisÃ©es, ce qui rend vos applications rapides, rÃ©silientes et plus faciles Ã  comprendre."
          },
          {
            "type": "paragraph",
            "text": "Vous voulez de l'aide pour migrer une application de Next.js vers Remix ou pour crÃ©er une nouvelle application Remix Ã  partir de zÃ©ro ? Faites-le moi savoir ! ğŸš€"
          }
        ]
      }
    ]
  }
}
